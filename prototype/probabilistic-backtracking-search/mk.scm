;;; This file was generated by writeminikanren.pl
;;; Generated at 2007-10-25 15:24:42

(define-syntax mzero 
  (syntax-rules () ((_) #f)))

(define-syntax inc 
  (syntax-rules () ((_ e) (lambdaf@ () e))))

(define-syntax unit 
  (syntax-rules () ((_ a) a)))

(define-syntax choice 
  (syntax-rules () ((_ a f) (cons a f))))


(define-syntax lambdag@
  (syntax-rules ()
    ((_ (p) e) (lambda (p) e))))

(define-syntax lambdaf@
  (syntax-rules ()
    ((_ () e) (lambda () e))))

(define-syntax run*
  (syntax-rules ()
    ((_ (x) g ...) (run #f (x) g ...))))

(define-syntax rhs
  (syntax-rules ()
    ((_ x) (cdr x))))

(define-syntax lhs
  (syntax-rules ()
    ((_ x) (car x))))

(define-syntax size-s
  (syntax-rules ()
    ((_ x) (length x))))

(define-syntax var
  (syntax-rules ()
    ((_ x) (vector x))))

(define-syntax var?
  (syntax-rules ()
    ((_ x) (vector? x))))


(define-syntax case-inf
  (syntax-rules ()
    ((_ e (() e0) ((f^) e1) ((a^) e2) ((a f) e3))
     (let ((a-inf e))
       (cond
         ((not a-inf) e0)
         ((procedure? a-inf)  (let ((f^ a-inf)) e1))
         ((not (and (pair? a-inf)
                    (procedure? (cdr a-inf))))
          (let ((a^ a-inf)) e2))
         (else (let ((a (car a-inf)) (f (cdr a-inf))) 
                 e3)))))))


(define empty-s '())

(define ext-s
  (lambda (x v s)
    (cons `(,x . ,v) s)))


(define empty-goal/c-ls '())

(define get-g/c-ls
  (lambda (c)
    (cadr c)))


(define empty-c `(,empty-s ,empty-goal/c-ls))

(define get-s (lambda (c) (car c)))

(define update-s
  (lambda (c s)
    (let ((g/c-ls (get-g/c-ls c)))
      `(,s ,g/c-ls))))

#|
(define ext-g/c-list
  (lambda (cg c)
    (let ((goal/c-ls (get-goal/c-ls c))
          (s (get-s c)))
      `(,s ((,cg . ,c) . ,goal/c-ls)))))
|#

(define ext-g/c-list
  (lambda (g c)
    (let ((g/c-ls (get-g/c-ls c))
          (s (get-s c)))
      `(,s ((,g . ,c) . ,g/c-ls)))))



(define resample
  (lambda (c)
    #;(printf "c: ~s\n" c)
    (let ((g/c-ls (get-g/c-ls c)))
      (if (null? g/c-ls)
          (mzero)
          (let ((pick (random (length g/c-ls))))
            (let ((g/c (list-ref g/c-ls pick)))
              (let ((g (car g/c))
                    (c (cdr g/c)))
                #;(printf "g: ~s\n" g)
                #;(printf "c: ~s\n" c)
                (g c))))))))



(define walk
  (lambda (u S)
    (cond
      ((and (var? u) (assq u S)) =>
       (lambda (pr) (walk (rhs pr) S)))
      (else u))))

(define unify
  (lambda (u v s)
    (let ((u (walk u s))
          (v (walk v s)))
      (cond
        ((eq? u v) s)
        ((var? u) (ext-s-check u v s))
        ((var? v) (ext-s-check v u s))
        ((and (pair? u) (pair? v))
         (let ((s (unify 
                    (car u) (car v) s)))
           (and s (unify 
                    (cdr u) (cdr v) s))))
        ((equal? u v) s)
        (else #f)))))

(define ext-s-check
  (lambda (x v s)
    (cond
      ((occurs-check x v s) #f)
      (else (ext-s x v s)))))

(define occurs-check
  (lambda (x v s)
    (let ((v (walk v s)))
      (cond
        ((var? v) (eq? v x))
        ((pair? v) 
         (or 
           (occurs-check x (car v) s)
           (occurs-check x (cdr v) s)))
        (else #f)))))

(define walk*
  (lambda (w s)
    (let ((v (walk w s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v)))))

(define reify-s
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v)
         (ext-s v (reify-name (size-s s)) s))
        ((pair? v) (reify-s (cdr v)
                     (reify-s (car v) s)))
        (else s)))))

(define reify-name
  (lambda (n)
    (string->symbol
      (string-append "_" "." (number->string n)))))

(define reify
  (lambda (v s)
    (let ((v (walk* v s)))
      (walk* v (reify-s v empty-s)))))


#|
(define-syntax run
  (syntax-rules ()
    ((_ n (x) g0 g ...)
     (take n
       (lambdaf@ ()
         ((fresh (x) g0 g ... 
            (lambdag@ (c)
              (let ((s (get-s c)))
                (cons (reify x s) '()))))
          empty-c))))))
|#

#|
(define-syntax run
  (syntax-rules ()
    ((_ n (x) g0 g ...)
     (let ((x (var 'x)))
       (take
        (trace-lambda 'reify-run (c)
          (let ((s (get-s c)))
            (reify x s)))
        n
        (lambdaf@ ()
          ((fresh () g0 g ...
             (lambdag@ (c)
               (cons c '())))
           empty-c)))))))
|#
#|
(define take
  (lambda (n f)
    (if (and n (zero? n)) 
      '()
      (case-inf (f)
        (() '())
        ((f) (take n f))
        ((a) a)
        ((a f)
         (cons (car a)
           (take (and n (- n 1)) f)))))))
|#

(define-syntax run
  (syntax-rules ()
    ((_ n (x) g0 g ...)
     (let ((x (var 'x)))
       (take
        (lambda (c)
          (let ((s (get-s c)))
            (reify x s)))
        n
        (lambdaf@ ()
          ((fresh () g0 g ...
             (lambdag@ (c)
               c))
           empty-c)))))))


#|
(trace-define take
  (lambda (rf n f)
    (if (and n (zero? n)) 
      '()
      (let ((ans (f)))
        (printf "ans: ~s\n" ans)
        (case-inf ans
          (()
           (begin
             (printf "t1\n")
             '()))
          ((f)
           (begin
             (printf "t2\n")
             (take rf n f)))
          ((a)
           (begin
             (printf "t3\n")
             (cons (rf (car a))
               (take rf (and n (- n 1)) (inc (resample (car a)))))))
          ((a f)
           (begin
             (printf "t4\n")
             (cons (rf (car a))
               (take rf (and n (- n 1)) f)))))))))
|#

(define take
  (lambda (rf n f)
    (if (and n (zero? n)) 
      '()
      (let ((ans (f)))
        #;(printf "ans: ~s\n" ans)
        (case-inf ans
          (()
           (begin
             #;(printf "t1\n")
             '()))
          ((f)
           (begin
             #;(printf "t2\n")
             (take rf n f)))
          ((a)
           (begin
             #;(printf "t3\n")
             (cons (rf a)
               (take rf (and n (- n 1)) (inc (resample a))))))
          ((a f)
           (begin
             #;(printf "t4\n")
             (cons (rf a)
               (take rf (and n (- n 1)) f)))))))))

#|
(define ==
  (lambda (u v)
    (lambdag@ (s)
      (unify u v s))))
|#



(define ==
  (lambda (u v)
    (lambdag@ (c)
      (let ((s (unify u v (get-s c))))
        (if s
            (update-s c s)
            (resample c))))))



(define-syntax fresh
  (syntax-rules ()
    ((_ (x ...) g0 g ...)
     (lambdag@ (c)
       (inc
         (let ((x (var 'x)) ...)
           (bind* (g0 c) g ...)))))))

(define-syntax bind*
  (syntax-rules ()
    ((_ e) e)
    ((_ e g0 g ...) (bind* (bind e g0) g ...))))

(define bind
  (lambda (a-inf g)
    (case-inf a-inf
      (() (mzero))
      ((f) (inc (bind (f) g)))
      ((a) (g a))
      ((a f) (mplus (g a) (lambdaf@ () (bind (f) g)))))))

#|
(define-syntax conde
  (syntax-rules ()
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (s) 
       (inc 
         (mplus* 
           (bind* (g0 s) g ...)
           (bind* (g1 s) g^ ...) ...))))))
|#

#|
;; probabilistic conde
(define-syntax conde
  (syntax-rules ()
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (c)
       (let ((cg (lambdag@ (c)
                   (let ((pick (random (length (list g0 g1 ...)))))
                     (list-ref
                       (list
                         (inc (bind* (g0 c) g ...))
                         (inc (bind* (g1 c) g^ ...))
                         ...)
                       pick)))))
         ;; save the cg/c so we can probabilistically backtrack later
         (let ((c (ext-g/c-list cg c)))
           (cg c)))))))
|#


;; probabilistic conde
(define-syntax conde
  (syntax-rules ()
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (c)
       (letrec ((cg (lambdag@ (c)
                      ;; save the cg/c so we can probabilistically backtrack later
                      (let ((c (ext-g/c-list cg c)))
                        (let ((pick (random (length (list g0 g1 ...)))))
                          (list-ref
                            (list
                              (inc (bind* (g0 c) g ...))
                              (inc (bind* (g1 c) g^ ...))
                              ...)
                            pick))))))
         (cg c))))))


#|
(define-syntax mplus*
  (syntax-rules ()
    ((_ e) e)
    ((_ e0 e ...) (mplus e0 
                    (lambdaf@ () (mplus* e ...))))))
|#
 
(define mplus
  (lambda (a-inf f)
    (case-inf a-inf
      (() (f))
      ((f^) (inc (mplus (f) f^)))
      ((a) (choice a f))
      ((a f^) (choice a (lambdaf@ () (mplus (f) f^)))))))

(define-syntax conda
  (syntax-rules ()
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (c)
       (inc
         (ifa ((g0 c) g ...)
              ((g1 c) g^ ...) ...))))))
 
(define-syntax ifa
  (syntax-rules ()
    ((_) (mzero))
    ((_ (e g ...) b ...)
     (let loop ((a-inf e))
       (case-inf a-inf
         (() (ifa b ...))
         ((f) (inc (loop (f))))
         ((a) (bind* a-inf g ...))
         ((a f) (bind* a-inf g ...)))))))

(define-syntax condu
  (syntax-rules ()
    ((_ (g0 g ...) (g1 g^ ...) ...)
     (lambdag@ (c)
       (inc
         (ifu ((g0 c) g ...)
              ((g1 c) g^ ...) ...))))))
 
(define-syntax ifu
  (syntax-rules ()
    ((_) (mzero))
    ((_ (e g ...) b ...)
     (let loop ((a-inf e))
       (case-inf a-inf
         (() (ifu b ...))
         ((f) (inc (loop (f))))
         ((a) (bind* a-inf g ...))
         ((a f) (bind* (unit a) g ...)))))))

(define-syntax project
  (syntax-rules ()
    ((_ (x ...) g g* ...)
     (lambdag@ (c)
       (let ((x (walk* x c)) ...)
         ((fresh () g g* ...) c))))))

(define succeed (== #f #f))

(define fail (== #f #t))

(define onceo
  (lambda (g)
    (condu
      (g succeed)
      ((== #f #f) fail))))
